# Http 面试题

## 说一下你知道的状态码?

- 100 继续
- 101 切换协议
- 200 请求成功
- 201 已创建, 成功请求并创建新的资源
- 202 已接收, 但未处理完成
- 301 资源永久重定向
- 302 临时重定向
- 400 请求语法错误
- 401 需要权限
- 404 请求页面不存在
- 500 内部服务器错误
- 501 服务端不支持请求功能, 无法完成请求

>1** 信息, 服务端收到请求, 需要请求者继续执行操作

>2** 成功, 操作被成功接收并处理

>3** 重定向, 需要进一步完成请求

>4** 客户端错误, 请求包含语法错误或无法完成请求

>5** 服务端错误, 服务器在处理请求的过程中发生错误

## Http 缓存?

- 一个网址的旅行:

```text
1、输入一个网址：www.baidu.com
2、浏览器查找域名的IP地址
3、浏览器给web服务器发送一个http请求
4、服务器给浏览器响应一个301永久重定向：会访问“http://www.baidu.com/” 而非“http://baidu.com/”
5、浏览器跟踪重定向地址
6、服务器处理请求，并返回一个HTML响应
7、浏览器开始显示HTML
```

- DNS 

>是一个域名系统，域名是互联网上的身份标识，是不可重复的唯一标识资源，DNS解析是互联网绝大多数应用的实际寻址方式 
在面试中他问到我这样一个问题：DNS解析发生在什么时候？  
当用户输入域名并敲回车后，系统就会调用DNS client，寻找到用户配置或者自动分配的DNS IP,之后就开始整个的解析过程

- 缓存

>返回一个HTML文件的时候你要考虑这个文件有没有缓存过，缓存过有没有变化。
一般静态文件会允许浏览器对其进行缓存，有的文件可能会不需要与服务器通讯，而从缓存中直接读取。
缓存有什么好处？这个就比较简单了，但是也会被问到，你就说 减少相应的延迟，减少网络带宽消耗

- Expires

>响应头，代表该资源的过期时间

- Cache-Control

>请求/响应头，缓存控制字段，精确控制缓存策略

- If-Modified-Since

>请求头，资源最近修改时间，由浏览器告诉服务器

- Last-Modified

>响应头，资源最近修改时间，由服务器告诉浏览器

- Etag

>响应头，资源标识，由服务器告诉浏览器

- If-None-Match

>请求头，缓存资源标识，由浏览器告诉服务器

### 讲一下浏览器缓存的发展过程

1. 浏览器总是从服务器里拿文件, **没缓存, 浪费带宽, 浪费时间, 用户体验不好**
2. 加入缓存机制, 在浏览器本地把文件存下, 每次请求就从本地请求,  
    - **优点:** 增加用户体验, 节省带宽
    - **缺点:** 不能拿到最新的数据
3. 加入缓存过期时间, 用 **Expires(GMT日期)** 设置, 第一次请求服务器就返回一个文件, 后面在请求就在本地缓存中, 当时间过期后在去服务器请求
    - **优点:** 能过一段时间拿到最新的文件
    - **缺点:** 缓存过期后, 不管服务器的资源有无更新, 都会重新都服务器读取文件
4. 服务器告诉浏览器上次文件的修改时间, 响应连同 **Expires 和 Last-Modified** 返回, 当缓存过期,
   浏览器就拿  **If-Modified-Since(等于服务器上次返回的Last-modified)** 就带到服务器上, 服务器看浏览器带来的最后一次修改时间是否与文件的修改时间相同
    - **优点:** 过期后如果内容没变, 就不需要重新获取, 节省带宽, 如果文件有变化, 则返回最新的文件数据
    - **缺点:** 
        - Expires 过期控制不稳定，因为浏览器端可**以随意修改时间(用户可以修改时间)**，导致缓存使用不精准, **Last-Modified 过期时间只能精确到秒**
        - 只能精确到秒, 那么如果一个文件在一秒内改了很多次, 都在那在一秒内对比, 服务器就会认为最后修改时间和上一次的一样, 所以会告诉浏览器继续使用原来的缓存, 但其实文件已经改了
        - 看似改了文件, 其实数据没发生变化, 但是 Last-Modified 匹配不上又会重新读取文件一次
>一致: 服务器告诉浏览器可以继续用原来的缓存了 **(304 未修改)** 

>不一致: 服务器读取文件返回给浏览器, 顺便把新的 Last-Modified 和 Expires 返回给浏览器

5. 增加相对时间的控制, 引入 Cache-Contorl, 浏览器除了得到 **Expires(绝对时间)**, 还会得到一个 **Cache-Control：max-age=10秒(相对时间)**, 
10秒的意思是在10秒内利用缓存在读文件, 浏览器以 Cache-Control 为准, 忽略 Expires, 如果没有 Cache-Control, 则检查 Expires

6. 解决精确到秒问题, 加入 **Etag(一般用MD5), 文件内容变了, Etag 才变, 内容不变, Etag 不变, Etag 就相当于这个文件的唯一 ID,** 同时引入 If-None-Match, 
当再次请求服务器的时候, **If-None-Match 就是服务器上次传来的 Etag**

#### 总结
>当浏览器第一次请求文件, 服务器会返回 Expires(绝对时间) 和 Cache-Control: max-age=10秒(相对时间), Last-Modified(最后修改时间), Etag(标识文件的唯一ID)

>10秒内再次请求直接去缓存里找

>11秒后请求就去服务器上, 忽略 If-Modified-Since(上次的 Last-Modified) , 对比一下 If-None-Match(上次的 Etag) , 如果有变化, 那就返回新的文件以及还是那四个响应头, 如果变化, 那就告诉浏览器还是从缓存里找

#### 还有一些问题

- 不管使用 Expires 或 Cache-Control 都**不能主动获取文件内容是否被改变**, 那么怎么解决?

众所周知不论 js、css、img 都是从 html 上在发请求获取的, 那么我们可以**不让 html 做缓存**, 每次请求 html 都是从服务器里读

每次拿到 html 里的时候在 **js 请求路径上加一个版本号**, 如果 html 再次访问 js 的版本还是和以前一样, 那么就从缓存找, 如果版本号变了, 那就重新请求

这样就解决了不能主动得知文件更新的问题, 再加上 **webpack 插件(html-webpack-plugin)的使用**, 每次会根据 hash 值生成不同名称的 html, 就可以很方便的去解决这个问题

[不错的 http 缓存 文章](https://juejin.im/post/5b3c87386fb9a04f9a5cb037#heading-1)

## GET 和 POST 的区别?

- 错解:
    - GET 在浏览器回退时是无害的, 而 POST 会再次提交请求
    - GET 在产生的 URL 地址上可以这加入收藏栏, 而 POST 不可以
    - GET 请求会被浏览器主动 cache, 而 POST 不会, 除非手动设置\
    - GET 请求只能进行 URL 编码, 而 POST 支持多种编码方式
    - GET 请求参数会被完整保留在浏览器历史记录里, 而 POST 中的参数不会被保留
    - GET 请求在 URL 中传送的参数是有长度限制的, 而 POST 没有
    - 对参数的数据类型, GET 只接受 ASCII 字符, 而 POST 没有限制
    - GET 比 POST 更不安全, 因为参数直接暴露在 URL 上, 所以不能传递敏感信息
    - GET 参数通过 URL 传递, POST 放在 Request Body 中
- 正解:
    - 就一个区别: 语义 --- GET 用于获取资源, POST 用于提交资源

:::tip 注意
HTTP 底层是 TCP/IP, 所以 GET 和 POST 都是 TCP链接
**TCP 像汽车**, 运输数据, 为了区分数据的类别, 给每个小汽车贴标
**GET 在汽车顶上运输, POST 在汽车里运输**

运输公司就相当于不同的浏览强和服务器, 装货卸货还是有很大的代价的, 所以他们会**限制单次运输量来控制风险**
浏览器通常限制 URL 长度在 **2k 字节,** 而服务器最多处理 **64k 大小的 URL**

**GET 产生一个数据包, POST 产生两个数据包**
GET 会把请求头和数据一起发到服务器, POST 会先发请求头告诉服务器有一些数据要来, 然后再回去发数据
看起来 GET 比 POST 更高效, 但是他们的**语义不同**, 不能随便混用, 而且走的网络环境差的情况下, 验证**两次包的数完整性更好**
并不是所有的浏览器都会在 POST 请求发两次包, **Firefox 就只发一次包** 
:::
    
>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同

[比较好的文章](https://zhuanlan.zhihu.com/p/22536382)

## Cookie 和 Session 和 LocalStorage 和 SessionStorage 区别?

- Cookie V.S. LocalStorage
    1. 主要是区别是 Cookie 会被发送到**服务器**, 而 LocalStorage **不会**
    2. Cookie 一般最大 **4k**, LocalStorage 可以用 **5mb 甚至 10mb**, 各浏览器不同
- LocalStorage V.S. SessionStorage
    1. LocalStorage 一般**不会自动过期**(除非用户自己清除), 而 SessionStorage 在**会话结束时期过期**(如关闭浏览器)
- Cookie V.S. Session
    1. Cookie **存在浏览器文件里**, Session **存在服务器的文件里**
    2. Session 是**基于 Cookie** 实现的, 具体做法就是把 SessionID 存在 Cookie 里

## HTTP1 和 HTTP2 的区别?

- 新的二进制格式: 利用二进制格式解析, 方便健壮
- 多路复用: 根据 Request id 来区分
- header 压缩: 缓存 header 列表, 避免重复传送
- 服务器推送: 在请求 style.css 的时候服务器自动把 main.js 放在浏览器的缓存里