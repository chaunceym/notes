# Http 面试题

## 说一下你知道的状态码?

- 100 继续
- 101 切换协议
- 200 请求成功
- 201 已创建, 成功请求并创建新的资源
- 202 已接收, 但未处理完成
- 301 资源永久重定向
- 302 临时重定向
- 400 请求语法错误
- 401 需要权限
- 404 请求页面不存在
- 500 内部服务器错误
- 501 服务端不支持请求功能, 无法完成请求

1** 信息, 服务端收到请求, 需要请求者继续执行操作
2** 成功, 操作被成功接收并处理
3** 重定向, 需要进一步完成请求
4** 客户端错误, 请求包含语法错误或无法完成请求
5** 服务端错误, 服务器在处理请求的过程中发生错误

## Http 缓存?

- 一个网址的旅行:

```text
1、输入一个网址：www.baidu.com
2、浏览器查找域名的IP地址
3、浏览器给web服务器发送一个http请求
4、服务器给浏览器响应一个301永久重定向：会访问“http://www.baidu.com/” 而非“http://baidu.com/”
5、浏览器跟踪重定向地址
6、服务器处理请求，并返回一个HTML响应
7、浏览器开始显示HTML
```

- DNS 

>是一个域名系统，域名是互联网上的身份标识，是不可重复的唯一标识资源，DNS解析是互联网绝大多数应用的实际寻址方式 
在面试中他问到我这样一个问题：DNS解析发生在什么时候？  
当用户输入域名并敲回车后，系统就会调用DNS client，寻找到用户配置或者自动分配的DNS IP,之后就开始整个的解析过程

- 缓存

>返回一个HTML文件的时候你要考虑这个文件有没有缓存过，缓存过有没有变化。
一般静态文件会允许浏览器对其进行缓存，有的文件可能会不需要与服务器通讯，而从缓存中直接读取。
缓存有什么好处？这个就比较简单了，但是也会被问到，你就说 减少相应的延迟，减少网络带宽消耗

- Expires

>响应头，代表该资源的过期时间

- Cache-Control

>请求/响应头，缓存控制字段，精确控制缓存策略

- If-Modified-Since

>请求头，资源最近修改时间，由浏览器告诉服务器

- Last-Modified

>响应头，资源最近修改时间，由服务器告诉浏览器

- Etag

>响应头，资源标识，由服务器告诉浏览器

- If-None-Match

>请求头，缓存资源标识，由浏览器告诉服务器

### 讲一下浏览器缓存的发展过程

1. 浏览器总是从服务器里拿文件, **没缓存, 浪费带宽, 浪费时间, 用户体验不好**
2. 加入缓存机制, 在浏览器本地把文件存下, 每次请求就从本地请求,  
    - **优点:** 增加用户体验, 节省带宽
    - **缺点:** 不能拿到最新的数据
3. 加入缓存过期时间, 用 **Expires(GMT日期)** 设置, 第一次请求服务器就返回一个文件, 后面在请求就在本地缓存中, 当时间过期后在去服务器请求
    - **优点:** 能过一段时间拿到最新的文件
    - **缺点:** 缓存过期后, 不管服务器的资源有无更新, 都会重新都服务器读取文件
4. 服务器告诉浏览器上次文件的修改时间, 响应连同 **Expires 和 Last-Modified** 返回, 当缓存过期,
   浏览器就拿  **If-Modified-Since(等于服务器上次返回的Last-modified)** 就带到服务器上, 服务器看浏览器带来的最后一次修改时间是否与文件的修改时间相同
    - **优点:** 过期后如果内容没变, 就不需要重新获取, 节省带宽, 如果文件有变化, 则返回最新的文件数据
    - **缺点:** 
        - Expires 过期控制不稳定，因为浏览器端可**以随意修改时间(用户可以修改时间)**，导致缓存使用不精准, **Last-Modified 过期时间只能精确到秒**
        - 只能精确到秒, 那么如果一个文件在一秒内改了很多次, 都在那在一秒内对比, 服务器就会认为最后修改时间和上一次的一样, 所以会告诉浏览器继续使用原来的缓存, 但其实文件已经改了
        - 看似改了文件, 其实数据没发生变化, 但是 Last-Modified 匹配不上又会重新读取文件一次
>一致: 服务器告诉浏览器可以继续用原来的缓存了 **(304 未修改)** 

>不一致: 服务器读取文件返回给浏览器, 顺便把新的 Last-Modified 和 Expires 返回给浏览器

5. 增加相对时间的控制, 引入 Cache-Contorl, 浏览器除了得到 **Expires(绝对时间)**, 还会得到一个 **Cache-Control：max-age=10秒(相对时间)**, 
10秒的意思是在10秒内利用缓存在读文件, 浏览器以 Cache-Control 为准, 忽略 Expires, 如果没有 Cache-Control, 则检查 Expires

6. 解决精确到秒问题, 加入 **Etag(一般用MD5), 文件内容变了, Etag 才变, 内容不变, Etag 不变, Etag 就相当于这个文件的唯一 ID,** 同时引入 If-None-Match, 
当再次请求服务器的时候, **If-None-Match 就是服务器上次传来的 Etag**

#### 总结
>当浏览器第一次请求文件, 服务器会返回 Expires(绝对时间) 和 Cache-Control: max-age=10秒(相对时间), Last-Modified(最后修改时间), Etag(标识文件的唯一ID)

>10秒内再次请求直接去缓存里找

>11秒后请求就去服务器上, 忽略 If-Modified-Since(上次的 Last-Modified) , 对比一下 If-None-Match(上次的 Etag) , 如果有变化, 那就返回新的文件以及还是那四个响应头, 如果变化, 那就告诉浏览器还是从缓存里找

#### 还有一些问题

- 不管使用 Expires 或 Cache-Control 都**不能主动获取文件内容是否被改变**, 那么怎么解决?

众所周知不论 js、css、img 都是从 html 上在发请求获取的, 那么我们可以**不让 html 做缓存**, 每次请求 html 都是从服务器里读

每次拿到 html 里的时候在 **js 请求路径上加一个版本号**, 如果 html 再次访问 js 的版本还是和以前一样, 那么就从缓存找, 如果版本号变了, 那就重新请求

这样就解决了不能主动得知文件更新的问题, 再加上 **webpack 插件(html-webpack-plugin)的使用**, 每次会根据 hash 值生成不同名称的 html, 就可以很方便的去解决这个问题

[不错的 http 缓存 文章](https://juejin.im/post/5b3c87386fb9a04f9a5cb037#heading-1)


