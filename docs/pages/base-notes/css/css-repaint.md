# 重绘与回流

回流和重绘可以说是每一个 web 开发者都经常听到的两个词语, 但是可能有很多人不清楚这两步具体做了什么

## 浏览器渲染过程

1. 解析 HTML, 生成 DOM 树, 解析 CSS, 生成 CSSOM树
2. 将 DOM 树和 CSSOM 树结合, 生成渲染树(Render tree)
3. Layout(回流): 根据生成的渲染树, 进行回流(layout), 得到节点的几何信息
4. Paint(重绘): 根据渲染树以及回流得到的几何信息, 得到节点的绝对像素
5. Display: 将像素发给 CPU, 显示在页面上, 而 CSS3 硬件加速的原理是新建合成层

## 生成渲染树

为了构建渲染树, 浏览器主要完成了以下工作

1. 从 DOM 树的根节点开始遍历每个可见节点
2. 对于每个可见节点, 找到 CSSOM 树中的对应规则, 并应用他们
3. 根据每个可见节点以及其对应的样式, 组合生成渲染树

节点也分可见和不可见, 不可见的包括

1. 不会渲染输出的节点: script meta link
2. 通过 CSS 隐藏的节点: display:none; 

## 何时发生回流重绘

>回流:

- 添加或删除可见的 DOM 元素
- 元素的位置发生变化
- 元素的尺寸发生变化(外边距, 内边框, 边框大小, 宽高等)
- 内容发生变化, 比如文本变化或图片替代
- 页面一开始渲染的时候
- 浏览器的窗口尺寸变化

:::tip 注意
回流一定会触发重绘, 而重绘不一定会触发回流
:::

## 浏览器的优化机制

现代浏览器都会通过队列化修改并批量优化重排过程, 浏览器会将修改放入队列里, 知道过了一段实际或者操作达到了一个阈值
, 才清空队列, 但是当获取布局信息操作的时候会强制队列刷新, 比如访问了一下方法

- offsetTop, offsetLeft, offsetWidth, offsetHeight
- scrollTop, scrollLeft, scrollWidth, scrollHeight
- clientTop, clientLeft, clientWidth, clientHeight
- getComputedStyle()
- getBoundingClientRect

在修改样式的时候, 最好避免使用上面属性, 他们会重新渲染队列, 如果使用最好将值缓存下来

## 减少回流和重绘

### 最小化重绘和重排

- 合并多次对 DOM 样式的修改, 一次处理
- 批量修改 DOM
    - 使元素脱离文档流, 脱离文档流就不会在渲染树上了
        - 隐藏元素, 应用修改, 重新显示
        - 使用文档判断在当前 DOM 之外构建一个子树, 再把它拷贝会文档
        - 将原始元素拷贝到一个脱离文档节点中, 修改节点后, 在替换原始的元素
    - 对其进行多次修改
    - 将元素带回到文档中
- 避免触发同步布局事件
- 对于复杂动画, 使用绝对定位脱离文档流
- CSS3 硬件加速 

[引用原文](https://github.com/chenjigeng/blog/issues/4)
